# Задачи към [Рекурсия и функции от по-висок ред](./)

## Задачи за рекурсия

### P1

Напишете програма, която използва рекурсивна функция за намиране на степен на число.


### P2

Напишете програма, която използва рекурсивна функция за намиране на степен на число, НО функцията е реализирана използвайки алгоритъма за бързо степенуване.

Той е следният(x е числото, y е степента):
- y=0 -> 1
- y > 0 и y е четно -> (x^2)^(y/2)
- y > 0 и y е нечетно -> x*(x^(y-1))

### P3

Напишете програма, която използва рекурсивна функция и принтира двоичното представяне на едно число.

### P4

Напишете програма, която използва рекурсивна функция за намиране на най-големия общ делител на две неотрицателни цели числа, поне едното от които е различно от 0.

### P5

Напишете програма, която прочита естествените числа n (n >= 1) и k (k > 1) и използва рекурсивна функция, която намира произведението на естествените числа от 1 до n със стъпка k.

### P6

Напишете програма, която използва рекурсивна функция за намиране на най-дългия общ суфикс на десетичните записи на две цели неотрицателни числа.

```
Например най-дългият суфикс на 1234 и 34234 е 234, а на 201 и 3101 е 1.
```

### P7

Напишете програма, която използва рекурсивна функции за проверка дали дадено положително цяло число е елемент на редицата на Фибоначи.

### P8

Напишете програма, която прочита масив от n цели числа (n > 0) и след това използва рекурсивна функция, за да ги изведе на конзолата в обратен ред.

### P9

Напишете програма, която прочита сортиран масив (n > 0) и използва рекурсивна функция, която добавя елемент на коректното място, като запазва наредбата на елементите.

### P10

Да се дефинира рекурсивна функция, която създава копие на символен низ в предварително заделена памет.

### P11

Напишете програма, която прочита от конзолата 2 масива-множества и намира тяхното сечение, обиденение и разлика.

### P12

Напишете програма, която прочита масив от цели числа и изпозлва рекурсивна функция, която премахва последното срещане на даден елемент от масива. Ако масива не съдържа този елемент, той не се променя.

### P13

Да се дефинира рекурсивна функция, която реализира двоично търсене на елемент в сортиран едномерен масив.

### P14

Напишете програма, която използва рекурсивна функция и слива сортирани във възходящ ред 2 символни низа.

### P15

Дадена е шахматна дъска с размерност NxM (1 <= M, N <= 20), във всяко поле на която е написана буква. Да се напише рекурсивна програма, която установява може ли да се прочете даден текст, тръгвайки от дадено поле и движейки се само с ход на кон.

### P16

Лабиринт ще представяме като булева квадратна матрица M(8x8).
Една клетка (i, j) ще наричаме проходима, ако елемента на тази позиция M\[i][j] е истина, в противен случай ще я наричаме непроходима.

а) Напишете програма, която проверява дали съществува път от съседни в хоризонтално и вертикално направление проходими клетки на лабиринта, който започва в горния му ляв ъгъл и завършва в долния му десен ъгъл.

б) Напишете програма, която намира всички пътища от съседни в хоризонтално и вертикално направление проходими клетки на лабиринта, започвайки от горния ляв ъгъл и завършвайки в долния десен ъгъл.

в) Напишете програма, която намира най-краткия път от горния ляв ъгъл до долния десен ъгъл на лабиринта от предишната задача, в случай че път съществува.

### P17 (Ханойски кули)

С тази задача е свързана една легенда. Във великия храм на Брама под купола, разположен точно в центъра на света, лежат 64 златни диска, които са поставени един върху друг нанизани на 3 елмазени сърцевини. Жреците на Брама пренасят дисковете един по един от едната сърцевина на другата строго съблюдавайки закона на Брама – голям диск не трябва да се поставя върху по-малък. В началото всички 64 диска се намирали на едната сърцевина, подредени по големина, като в основата се намирал най-големият диск, образувайки кулата на Брама. Когато всички дискове бъдат пренесени на другата сърцевина, ще настъпи краят на света.

Да се напише програма за пренасяне на k диска от едната сърцевина на другата като се използва една помощна сърцевина.

## Задачи за функции от по-висок ред

### P1

Напишете програма, която прочита цял ред низ (с максимална големина 1024) от конзолата. Да се реализира функция, която извършва операция върху всяко една буква приемаща указател към функция. Реализирайте 2 помощни функции, които да се подават с указател:

- toLowerCase - преобразува главните букви в малки,
- toUpperCase - преобразува малките букви в главни.

```
Вход:
Hello world 1+2+#!

Изход:
HELLO WORLD 1+2+#!
hello world 1+2+#!
```

### P2

Напишете програма, която прочита масив (с максимална големина от 100) от цели числа. Напишете функция sort, която приема фунцкия за сортиране като указател. Реализирайте следните функции за сортиране:

- bubble sort,
- insertion sort,
- merge sort.

```
Вход:
6
4 3 6 1 5 2

Изход:
Bubble sort: 1 2 3 4 5 6
Insertion sort: 1 2 3 4 5 6
Merge sort: 1 2 3 4 5 6
```

### P3

Реализирайте функцията за натрупаване accumulate със следната сигнатура:

```
int accumulate(int from, int to, ... term, ... op, int startingValue); // на местата на ... трябва сами да определите какъв ще е подходящият тип
```

където:

- **[from, to]** е интервал от цели числа,
- **term** е функция над цели числа; тази функция ще извърша промяна над сегашното цяло число x,
- **op** е бинарна операция над стойностите получени чрез прилагане на term(x); сбор, разлика, произведение,
- **startingValue** е начална стойност, която се подава на op в началото.

Примерна употреба:

``` c
int id(int num) {
    return num;
}

int pow2(int num) {
    return num * num;
}

int sum(int firstNum, int secondNum) {
    return firstNum + secondNum;
}

int product(int firstNum, int secondNum) {
    return firstNum * secondNum;
}
int main() {
    printf("%d\n", accumulate(1, 4, id, sum, 0)); // 10
    printf("%d\n", accumulate(1, 4, pow2, sum, 0)); // 30
    printf("%d\n", accumulate(1, 5, id, product, 1)); // 120

    return 0;
}
```

### P4

Реализирайте функция map, която приема масив от произволен тип и функция от по-висок ред, която приема само един параметър от същия произволен тип като масива и променя параметъра по някакъв начин.

Реализирайте функция filter, която приема масив от произволен тип и функция от по-висок ред, която ще е предикат. filter ще премахва всеки елемент от масива, който не удовлетворява предиката.

Примерна употреба:

``` c
#define ARR_SIZE = 5;

void multBy2(int* num) {
    *num *= 2;
}

bool divBy4(int num) {
    return num % 4 == 0;
}

int main() {
    int arr[ARR_SIZE] = { 1, 2, 3, 4, 5 };

    map(arr, ARR_SIZE, multBy2); // 2 4 6 8 10
    filter(arr, ARR_SIZE, divBy4); // 4 8

    return 0;
}
```

### P5

Реализирайте функция за натрупване при масиви **fold** със следната сигнатура:

``` c++

... fold(... arr, std::size_t size, ... op, ... startingValue);

```

където:
- **arr** е масив от произволен тип и **size** е неговата големина
- **op** е бинарна операция, която ще приема типа на **startingValue** и типа на **arr** и ще връща типа на **startingValue**
- **startingValue** е начална стойност, която се подава на op в началото

Примерна употреба:

``` c
#define ARR_SIZE = 5;

int max2(int firstNum, int secondNum) {
    return max(firstNum, secondNum);
}

char anyEven(bool res, int num) {
    return res || num % 2 == 0;
}

int main() {
    int arr[ARR_SIZE] = { 1, 2, 8, 4, 5 };

    printf("%d", fold(arr, ARR_SIZE, max2, arr[0])); // 8
    printf("%d", fold(arr, ARR_SIZE, anyEven, 0)); // 1

    return 0;
}
```

